% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualization.R
\name{embed_plot}
\alias{embed_plot}
\title{Embedding Plot, Colored By Category}
\usage{
embed_plot(coords, colors = NULL, x = NULL,
  color_scheme = grDevices::rainbow, num_colors = 15, limits = NULL,
  top = NULL, cex = 1, text = NULL, equal_axes = FALSE)
}
\arguments{
\item{coords}{Matrix of embedded coordinates, with as many rows as
observations, and 2 columns.}

\item{colors}{Vector containing colors for each coordinate.}

\item{x}{Either a data frame or a column that can be used to derive a
suitable vector of colors. Ignored if \code{colors} is provided.}

\item{color_scheme}{Either a color ramp function, or the name of a
ColorBrewer scheme. See 'Details'.}

\item{num_colors}{Number of unique colors to map to from \code{x}, if
\code{x} is a numeric vector. Otherwise ignored.}

\item{limits}{The range that the colors should map over when mapping from a
numeric vector. If not specified, then the range of \code{x}. This is useful
if there is some external absolute scale that should be used. Ignored if
\code{x} is not a numeric vector.}

\item{top}{If not \code{NULL}, only the specified number of points will be
displayed, corresponding to those with the highest values in \code{vec},
after sorting by decreasing order.
num_colors = 15, limits = NULL, top = NULL,}

\item{cex}{Size of the points. Ignored if \code{as_text} is \code{TRUE}.}

\item{text}{Vector of label text to display instead of a point. If the labels
are long or the data set is large, this is unlikely to be very legible, but
is occasionally useful.}

\item{equal_axes}{If \code{TRUE}, the X and Y axes are set to have the
same extents.}
}
\description{
Plots the embedded coordinates, with each point colored by a specified
color.
}
\details{
The \code{x} argument can be used to provide a suitable vector of colors
from either a data frame or vector.

If a data frame is provided, then a vector of colors will be looked for. If
it's present, it will be used as the \code{colors} argument directly.
Otherwise, a factor column will be looked for, and each level will be mapped
to a different color. Otherwise, one color will be used for each point. If
more than one column of a type is found in the data frame, the last one
encountered is used.

If a vector is provided, a similar procedure to the data frame is used when
mapping from its content to a vector of colors. Additionally, a numeric vector
can be provided, which will be linearly mapped to a color scheme.

The \code{color_scheme} parameter can be one of either a color ramp function,
accepting an integer n as an argument and returning n colors, or the name of
a ColorBrewer color scheme. Probably should be one of the "Qualitative" set.

For some applicable color ramp functions, see the \code{Palettes} help page
in the \code{grDevices} package (e.g. by running the \code{?rainbow} command).
}
\note{
Use of this function with ColorBrewer qualitative palette names
requires that the \code{RColorBrewer} package be installed.

More information on ColorBrewer is available at its website,
 \url{http://www.colorbrewer2.org}.
}
\examples{
\dontrun{
# Embed with PCA
pca_iris <- sneer(iris, method = "pca", scale_type = "a", ret = c("dy"))
# Visualize the resulting embedding, colored by iris species, using the
# rainbow color scheme
embed_plot(pca_iris$coords, x = iris$Species, color_scheme = rainbow)

# topo.colors scheme
embed_plot(pca_iris$coords, x = iris$Species, color_scheme = topo.colors)

# Pass in data frame and it will use any factor column it finds
embed_plot(pca_iris$coords, x = iris)

#' library("RColorBrewer")
# Use the "Dark2" ColorBrewer scheme
embed_plot(pca_iris$coords, x = iris, color_scheme = "Dark2")

# Can plot the category names instead of points, but looks bad if they're
# long (or the dataset is large)
embed_plot(pca_iris$coords, x = iris$Species, cex = 0.5, as_text = TRUE)

tsne_iris <- sneer(iris, method = "tsne", scale_type = "a",
                   ret = c("dx", "dy", "deg"))
# how well is the 32 nearest neighborhood preserved for each point?
nbr_pres_32 <- nbr_pres(tsne_iris$dx, tsne_iris$dy, 32)
# visualize preservation, use absolute scale of 0-1 for colors.
embed_plot(tsne_iris$coords, x = nbr_pres_32, limits = c(0, 1))

# visualize 10 points with the hightest degree centrality
embed_plot(tsne_iris$coords, x = tsne_iris$deg, top = 10)
}
}

